{
  "version": 3,
  "sources": ["../../@trpc/server/dist/observable-ade1bad8.mjs", "../../@trpc/server/dist/observable/index.mjs", "../../@trpc/client/dist/splitLink-4c75f7be.mjs", "../../@trpc/client/dist/transformResult-ace864b8.mjs", "../../@trpc/client/dist/TRPCClientError-0de4d231.mjs", "../../@trpc/server/dist/codes-c924c3db.mjs", "../../@trpc/server/dist/index-f91d720c.mjs", "../../@trpc/server/dist/transformTRPCResponse-1153b421.mjs", "../../@trpc/client/dist/httpUtils-0cb58db4.mjs", "../../@trpc/client/dist/httpBatchLink-cee1f56c.mjs", "../../@trpc/client/dist/links/httpLink.mjs", "../../@trpc/client/dist/index.mjs", "../../trpc-sveltekit/dist/client.js", "../../@trpc/server/dist/TRPCError-6a1653a4.mjs", "../../@trpc/server/dist/config-cd32070b.mjs", "../../@trpc/server/dist/contentType-53e30af8.mjs", "../../@trpc/server/dist/resolveHTTPResponse-67085326.mjs", "../../trpc-sveltekit/dist/server.js"],
  "sourcesContent": ["function identity(x) {\n    return x;\n}\n\n/** @internal */ function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn)=>fn(prev), input);\n    };\n}\n\nfunction isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\nfunction observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return pipeFromArray(operations)(self);\n        }\n    };\n    return self;\n}\n\nexport { isObservable as i, observable as o };\n", "export { i as isObservable, o as observable } from '../observable-ade1bad8.mjs';\n\nfunction share(_opts) {\n    return (originalObserver)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = originalObserver.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return {\n            subscribe (observer) {\n                refCount++;\n                observers.push(observer);\n                startIfNeeded();\n                return {\n                    unsubscribe () {\n                        refCount--;\n                        resetIfNeeded();\n                        const index = observers.findIndex((v)=>v === observer);\n                        if (index > -1) {\n                            observers.splice(index, 1);\n                        }\n                    }\n                };\n            }\n        };\n    };\n}\n\nfunction map(project) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer) {\n                let index = 0;\n                const subscription = originalObserver.subscribe({\n                    next (value) {\n                        observer.next?.(project(value, index++));\n                    },\n                    error (error) {\n                        observer.error?.(error);\n                    },\n                    complete () {\n                        observer.complete?.();\n                    }\n                });\n                return subscription;\n            }\n        };\n    };\n}\n\nfunction tap(observer) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer2) {\n                return originalObserver.subscribe({\n                    next (v) {\n                        observer.next?.(v);\n                        observer2.next?.(v);\n                    },\n                    error (v) {\n                        observer.error?.(v);\n                        observer2.error?.(v);\n                    },\n                    complete () {\n                        observer.complete?.();\n                        observer2.complete?.();\n                    }\n                });\n            }\n        };\n    };\n}\n\nclass ObservableAbortError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'ObservableAbortError';\n        Object.setPrototypeOf(this, ObservableAbortError.prototype);\n    }\n}\n/** @internal */ function observableToPromise(observable) {\n    let abort;\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            reject(new ObservableAbortError('This operation was aborted.'));\n            obs$.unsubscribe();\n        }\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                isDone = true;\n                reject(data);\n                onDone();\n            },\n            complete () {\n                isDone = true;\n                onDone();\n            }\n        });\n        abort = onDone;\n    });\n    return {\n        promise,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        abort: abort\n    };\n}\n\nexport { map, observableToPromise, share, tap };\n", "import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction splitLink(opts) {\n    return (runtime)=>{\n        const yes = asArray(opts.true).map((link)=>link(runtime));\n        const no = asArray(opts.false).map((link)=>link(runtime));\n        return (props)=>{\n            return observable((observer)=>{\n                const links = opts.condition(props.op) ? yes : no;\n                return createChain({\n                    op: props.op,\n                    links\n                }).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { createChain as c, splitLink as s };\n", "function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, runtime) {\n    if ('error' in response) {\n        const error = runtime.transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: runtime.transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, runtime) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, runtime);\n    } catch (err) {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { isObject as i, transformResult as t };\n", "import { i as isObject } from './transformResult-ace864b8.mjs';\n\nfunction isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause instanceof Error && cause.name === 'TRPCClientError';\n}\nfunction isTRPCErrorResponse(obj) {\n    return isObject(obj) && isObject(obj.error) && typeof obj.error.code === 'number' && typeof obj.error.message === 'string';\n}\nclass TRPCClientError extends Error {\n    static from(_cause, opts = {}) {\n        const cause = _cause;\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        if (isTRPCErrorResponse(cause)) {\n            return new TRPCClientError(cause.error.message, {\n                ...opts,\n                result: cause\n            });\n        }\n        if (!(cause instanceof Error)) {\n            return new TRPCClientError('Unknown error', {\n                ...opts,\n                cause: cause\n            });\n        }\n        return new TRPCClientError(cause.message, {\n            ...opts,\n            cause\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError as T };\n", "/**\n * @internal\n */ function invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\n\nexport { TRPC_ERROR_CODES_BY_KEY as T, TRPC_ERROR_CODES_BY_NUMBER as a, invert as i };\n", "import { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n\nconst noop = ()=>{\n// noop\n};\nfunction createInnerProxy(callback, path) {\n    const proxy = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ]);\n        },\n        apply (_1, _2, args) {\n            const isApply = path[path.length - 1] === 'apply';\n            return callback({\n                args: isApply ? args.length >= 2 ? args[1] : [] : args,\n                path: isApply ? path.slice(0, -1) : path\n            });\n        }\n    });\n    return proxy;\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, []);\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { TRPC_ERROR_CODES_BY_NUMBER as T, createRecursiveProxy as a, getHTTPStatusCode as b, createFlatProxy as c, getHTTPStatusCodeFromError as g };\n", "import { g as getHTTPStatusCodeFromError } from './index-f91d720c.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\n/**\n * @internal\n */ function getErrorShape(opts) {\n    const { path , error , config  } = opts;\n    const { code  } = opts.error;\n    const shape = {\n        message: error.message,\n        code: TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === 'string') {\n        shape.data.stack = opts.error.stack;\n    }\n    if (typeof path === 'string') {\n        shape.data.path = path;\n    }\n    return config.errorFormatter({\n        ...opts,\n        shape\n    });\n}\n\nfunction transformTRPCResponseItem(config, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n\nexport { getErrorShape as g, transformTRPCResponse as t };\n", "import { T as TRPCClientError } from './TRPCClientError-0de4d231.mjs';\n\nconst isFunction = (fn)=>typeof fn === 'function';\nfunction getFetch(customFetchImpl) {\n    if (customFetchImpl) {\n        return customFetchImpl;\n    }\n    if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n        return window.fetch;\n    }\n    if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n        return globalThis.fetch;\n    }\n    throw new Error('No fetch implementation found');\n}\n\nfunction getAbortController(customAbortControllerImpl) {\n    if (customAbortControllerImpl) {\n        return customAbortControllerImpl;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.AbortController) {\n        return window.AbortController;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.AbortController) {\n        return globalThis.AbortController;\n    }\n    return null;\n}\n\nfunction resolveHTTPLinkOptions(opts) {\n    return {\n        url: opts.url,\n        fetch: opts.fetch,\n        AbortController: getAbortController(opts.AbortController)\n    };\n}\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array) {\n    const dict = {};\n    for(let index = 0; index < array.length; index++){\n        const element = array[index];\n        dict[index] = element;\n    }\n    return dict;\n}\nconst METHOD = {\n    query: 'GET',\n    mutation: 'POST'\n};\nfunction getInput(opts) {\n    return 'input' in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input)=>opts.runtime.transformer.serialize(_input)));\n}\nconst getUrl = (opts)=>{\n    let url = opts.url + '/' + opts.path;\n    const queryParts = [];\n    if ('inputs' in opts) {\n        queryParts.push('batch=1');\n    }\n    if (opts.type === 'query') {\n        const input = getInput(opts);\n        if (input !== undefined) {\n            queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n        }\n    }\n    if (queryParts.length) {\n        url += '?' + queryParts.join('&');\n    }\n    return url;\n};\nconst getBody = (opts)=>{\n    if (opts.type === 'query') {\n        return undefined;\n    }\n    const input = getInput(opts);\n    return input !== undefined ? JSON.stringify(input) : undefined;\n};\nconst jsonHttpRequester = (opts)=>{\n    return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        getUrl,\n        getBody\n    });\n};\nasync function fetchHTTPResponse(opts, ac) {\n    const url = opts.getUrl(opts);\n    const body = opts.getBody(opts);\n    const { type  } = opts;\n    const resolvedHeaders = await opts.headers();\n    /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n        throw new Error('Subscriptions should use wsLink');\n    }\n    const headers = {\n        ...opts.contentTypeHeader ? {\n            'content-type': opts.contentTypeHeader\n        } : {},\n        ...opts.batchModeHeader ? {\n            'trpc-batch-mode': opts.batchModeHeader\n        } : {},\n        ...resolvedHeaders\n    };\n    return getFetch(opts.fetch)(url, {\n        method: METHOD[type],\n        signal: ac?.signal,\n        body: body,\n        headers\n    });\n}\nfunction httpRequest(opts) {\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const meta = {};\n    let done = false;\n    const promise = new Promise((resolve, reject)=>{\n        fetchHTTPResponse(opts, ac).then((_res)=>{\n            meta.response = _res;\n            done = true;\n            return _res.json();\n        }).then((json)=>{\n            meta.responseJSON = json;\n            resolve({\n                json: json,\n                meta\n            });\n        }).catch((err)=>{\n            done = true;\n            reject(TRPCClientError.from(err, {\n                meta\n            }));\n        });\n    });\n    const cancel = ()=>{\n        if (!done) {\n            ac?.abort();\n        }\n    };\n    return {\n        promise,\n        cancel\n    };\n}\n\nexport { getBody as a, getFetch as b, fetchHTTPResponse as f, getUrl as g, httpRequest as h, jsonHttpRequester as j, resolveHTTPLinkOptions as r };\n", "import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-0de4d231.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-0cb58db4.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items,\n                cancel: throwFatalError\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const unitResolver = (index, value)=>{\n                const item = batch.items[index];\n                item.resolve?.(value);\n                item.batch = null;\n                item.reject = null;\n                item.resolve = null;\n            };\n            const { promise , cancel  } = batchLoader.fetch(batch.items.map((_item)=>_item.key), unitResolver);\n            batch.cancel = cancel;\n            promise.then((result)=>{\n                for(let i = 0; i < result.length; i++){\n                    const value = result[i];\n                    unitResolver(i, value);\n                }\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        const cancel = ()=>{\n            item.aborted = true;\n            if (item.batch?.items.every((item)=>item.aborted)) {\n                // All items in the batch have been cancelled\n                item.batch.cancel();\n                item.batch = null;\n            }\n        };\n        return {\n            promise,\n            cancel\n        };\n    }\n    return {\n        load\n    };\n}\n\n/**\n * @internal\n */ function createHTTPBatchLink(requester) {\n    return function httpBatchLink(opts) {\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        const maxURLLength = opts.maxURLLength ?? Infinity;\n        // initialized config\n        return (runtime)=>{\n            const batchLoader = (type)=>{\n                const validate = (batchOps)=>{\n                    if (maxURLLength === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        inputs\n                    });\n                    return url.length <= maxURLLength;\n                };\n                const fetch = requester({\n                    ...resolvedOpts,\n                    runtime,\n                    type,\n                    opts\n                });\n                return {\n                    validate,\n                    fetch\n                };\n            };\n            const query = dataLoader(batchLoader('query'));\n            const mutation = dataLoader(batchLoader('mutation'));\n            const subscription = dataLoader(batchLoader('subscription'));\n            const loaders = {\n                query,\n                subscription,\n                mutation\n            };\n            return ({ op  })=>{\n                return observable((observer)=>{\n                    const loader = loaders[op.type];\n                    const { promise , cancel  } = loader.load(op);\n                    let _res = undefined;\n                    promise.then((res)=>{\n                        _res = res;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta: res.meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((err)=>{\n                        observer.error(TRPCClientError.from(err, {\n                            meta: _res?.meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n            };\n        };\n    };\n}\n\nconst batchRequester = (requesterOpts)=>{\n    return (batchOps)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { promise , cancel  } = jsonHttpRequester({\n            ...requesterOpts,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        });\n        return {\n            promise: promise.then((res)=>{\n                const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                const result = resJSON.map((item)=>({\n                        meta: res.meta,\n                        json: item\n                    }));\n                return result;\n            }),\n            cancel\n        };\n    };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\n\nexport { createHTTPBatchLink as c, httpBatchLink as h };\n", "import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-ace864b8.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-0de4d231.mjs';\nimport { r as resolveHTTPLinkOptions, j as jsonHttpRequester } from '../httpUtils-0cb58db4.mjs';\n\nfunction httpLinkFactory(factoryOpts) {\n    return (opts)=>{\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        return (runtime)=>({ op  })=>observable((observer)=>{\n                    const { path , input , type  } = op;\n                    const { promise , cancel  } = factoryOpts.requester({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        input,\n                        headers () {\n                            if (!opts.headers) {\n                                return {};\n                            }\n                            if (typeof opts.headers === 'function') {\n                                return opts.headers({\n                                    op\n                                });\n                            }\n                            return opts.headers;\n                        }\n                    });\n                    let meta = undefined;\n                    promise.then((res)=>{\n                        meta = res.meta;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((cause)=>{\n                        observer.error(TRPCClientError.from(cause, {\n                            meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n    };\n}\n/**\n * @see https://trpc.io/docs/client/links/httpLink\n */ const httpLink = httpLinkFactory({\n    requester: jsonHttpRequester\n});\n\nexport { httpLink, httpLinkFactory };\n", "import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-0de4d231.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-0de4d231.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-0cb58db4.mjs';\nexport { b as getFetch } from './httpUtils-0cb58db4.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-cee1f56c.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-cee1f56c.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-ace864b8.mjs';\n\nclass TRPCUntypedClient {\n    $request({ type , input , path , context ={}  }) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                id: ++this.requestId,\n                type,\n                path,\n                input,\n                context\n            }\n        });\n        return chain$.pipe(share());\n    }\n    requestAsPromise(opts) {\n        const req$ = this.$request(opts);\n        const { promise , abort  } = observableToPromise(req$);\n        const abortablePromise = new Promise((resolve, reject)=>{\n            opts.signal?.addEventListener('abort', abort);\n            promise.then((envelope)=>{\n                resolve(envelope.result.data);\n            }).catch((err)=>{\n                reject(TRPCClientError.from(err));\n            });\n        });\n        return abortablePromise;\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts?.context\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                if (envelope.result.type === 'started') {\n                    opts.onStarted?.();\n                } else if (envelope.result.type === 'stopped') {\n                    opts.onStopped?.();\n                } else {\n                    opts.onData?.(envelope.result.data);\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        this.requestId = 0;\n        const combinedTransformer = (()=>{\n            const transformer = opts.transformer;\n            if (!transformer) {\n                return {\n                    input: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    },\n                    output: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    }\n                };\n            }\n            if ('input' in transformer) {\n                return opts.transformer;\n            }\n            return {\n                input: transformer,\n                output: transformer\n            };\n        })();\n        this.runtime = {\n            transformer: {\n                serialize: (data)=>combinedTransformer.input.serialize(data),\n                deserialize: (data)=>combinedTransformer.output.deserialize(data)\n            },\n            combinedTransformer\n        };\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */ function createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    return client;\n}\n\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */ function createTRPCClientProxy(client) {\n    return createFlatProxy((key)=>{\n        if (client.hasOwnProperty(key)) {\n            return client[key];\n        }\n        if (key === '__untypedClient') {\n            return client;\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n            const fullPath = pathCopy.join('.');\n            return client[procedureType](fullPath, ...args);\n        });\n    });\n}\nfunction createTRPCProxyClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client.__untypedClient;\n}\n\nfunction getTextDecoder(customTextDecoder) {\n    if (customTextDecoder) {\n        return customTextDecoder;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && window.TextDecoder) {\n        return new window.TextDecoder();\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n        return new globalThis.TextDecoder();\n    }\n    throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */ async function parseJSONStream(opts) {\n    const parse = opts.parse ?? JSON.parse;\n    const onLine = (line)=>{\n        if (opts.signal?.aborted) return;\n        if (!line || line === '}') {\n            return;\n        }\n        /**\n     * At this point, `line` can be one of two things:\n     * - The first line of the stream `{\"2\":{...}`\n     * - A line in the middle of the stream `,\"2\":{...}`\n     */ const indexOfColon = line.indexOf(':');\n        const indexAsStr = line.substring(2, indexOfColon - 1);\n        const text = line.substring(indexOfColon + 1);\n        opts.onSingle(Number(indexAsStr), parse(text));\n    };\n    await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */ async function readLines(readableStream, onLine, textDecoder) {\n    let partOfLine = '';\n    const onChunk = (chunk)=>{\n        const chunkText = textDecoder.decode(chunk);\n        const chunkLines = chunkText.split('\\n');\n        if (chunkLines.length === 1) {\n            partOfLine += chunkLines[0];\n        } else if (chunkLines.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n            onLine(partOfLine + chunkLines[0]);\n            for(let i = 1; i < chunkLines.length - 1; i++){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n                onLine(chunkLines[i]);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n            partOfLine = chunkLines[chunkLines.length - 1];\n        }\n    };\n    // we handle 2 different types of streams, this if where we figure out which one we have\n    if ('getReader' in readableStream) {\n        await readStandardChunks(readableStream, onChunk);\n    } else {\n        await readNodeChunks(readableStream, onChunk);\n    }\n    onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */ function readNodeChunks(stream, onChunk) {\n    return new Promise((resolve)=>{\n        stream.on('data', onChunk);\n        stream.on('end', resolve);\n    });\n}\n/**\n * Handle WebAPI stream\n */ async function readStandardChunks(stream, onChunk) {\n    const reader = stream.getReader();\n    let readResult = await reader.read();\n    while(!readResult.done){\n        onChunk(readResult.value);\n        readResult = await reader.read();\n    }\n}\nconst streamingJsonHttpRequester = (opts, onSingle)=>{\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const responsePromise = fetchHTTPResponse({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        batchModeHeader: 'stream',\n        getUrl,\n        getBody: getBody$1\n    }, ac);\n    const cancel = ()=>ac?.abort();\n    const promise = responsePromise.then(async (res)=>{\n        if (!res.body) throw new Error('Received response without body');\n        const meta = {\n            response: res\n        };\n        return parseJSONStream({\n            readableStream: res.body,\n            onSingle,\n            parse: (string)=>({\n                    json: JSON.parse(string),\n                    meta\n                }),\n            signal: ac?.signal,\n            textDecoder: opts.textDecoder\n        });\n    });\n    return {\n        cancel,\n        promise\n    };\n};\n\nconst streamRequester = (requesterOpts)=>{\n    const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n    return (batchOps, unitResolver)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { cancel , promise  } = streamingJsonHttpRequester({\n            ...requesterOpts,\n            textDecoder,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        }, (index, res)=>{\n            unitResolver(index, res);\n        });\n        return {\n            /**\n       * return an empty array because the batchLoader expects an array of results\n       * but we've already called the `unitResolver` for each of them, there's\n       * nothing left to do here.\n       */ promise: promise.then(()=>[]),\n            cancel\n        };\n    };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\n\nconst getBody = (opts)=>{\n    if (!('input' in opts)) {\n        return undefined;\n    }\n    if (!(opts.input instanceof FormData)) {\n        throw new Error('Input is not FormData');\n    }\n    return opts.input;\n};\nconst formDataRequester = (opts)=>{\n    if (opts.type !== 'mutation') {\n        // TODO(?) handle formdata queries\n        throw new Error('We only handle mutations with formdata');\n    }\n    return httpRequest({\n        ...opts,\n        getUrl () {\n            return `${opts.url}/${opts.path}`;\n        },\n        getBody\n    });\n};\nconst experimental_formDataLink = httpLinkFactory({\n    requester: formDataRequester\n});\n\nexport { TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };\n", "import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\n/**\n * Create a tRPC client.\n * @see https://trpc.io/docs/vanilla\n */\nexport function createTRPCClient({ links, url = '/trpc', transformer, init, headers } = {\n    url: '/trpc'\n}) {\n    if (links)\n        return createTRPCProxyClient({ transformer, links });\n    if (typeof window === 'undefined' && !init) {\n        throw new Error('Calling createTRPCClient() on the server requires passing a valid LoadEvent argument');\n    }\n    return createTRPCProxyClient({\n        transformer,\n        links: [\n            httpBatchLink({\n                url: typeof window === 'undefined' ? `${init.url.origin}${url}` : `${location.origin}${url}`,\n                fetch: typeof window === 'undefined' ? init.fetch : init?.fetch ?? window.fetch,\n                headers\n            })\n        ]\n    });\n}\n", "/**\n * @internal\n */ function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) {\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause\n    });\n    // Inherit stack from error\n    if (cause instanceof Error && cause.stack) {\n        trpcError.stack = cause.stack;\n    }\n    return trpcError;\n}\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = opts.code;\n        this.name = this.constructor.name;\n    }\n}\n\nexport { TRPCError as T, getTRPCErrorFromUnknown as g };\n", "import { T as TRPCError } from './TRPCError-6a1653a4.mjs';\nimport { a as createRecursiveProxy, g as getHTTPStatusCodeFromError } from './index-f91d720c.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-c924c3db.mjs';\n\n/**\n * @public\n */ /**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    _default: true,\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\n\nconst defaultFormatter = ({ shape  })=>{\n    return shape;\n};\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\n\nconst procedureTypes = [\n    'query',\n    'mutation',\n    'subscription'\n];\n\nfunction isRouter(procedureOrRouter) {\n    return 'router' in procedureOrRouter._def;\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    return function createRouterInner(procedures) {\n        const reservedWordsUsed = new Set(Object.keys(procedures).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const routerProcedures = omitPrototype({});\n        function recursiveGetPaths(procedures, path = '') {\n            for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})){\n                const newPath = `${path}${key}`;\n                if (isRouter(procedureOrRouter)) {\n                    recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);\n                    continue;\n                }\n                if (routerProcedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                routerProcedures[newPath] = procedureOrRouter;\n            }\n        }\n        recursiveGetPaths(procedures);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures: routerProcedures,\n            ...emptyRouter,\n            record: procedures,\n            queries: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.query).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            mutations: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.mutation).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            subscriptions: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.subscription).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {})\n        };\n        const router = {\n            ...procedures,\n            _def,\n            createCaller (ctx) {\n                const proxy = createRecursiveProxy(({ path , args  })=>{\n                    // interop mode\n                    if (path.length === 1 && procedureTypes.includes(path[0])) {\n                        return callProcedure({\n                            procedures: _def.procedures,\n                            path: args[0],\n                            rawInput: args[1],\n                            ctx,\n                            type: path[0]\n                        });\n                    }\n                    const fullPath = path.join('.');\n                    const procedure = _def.procedures[fullPath];\n                    let type = 'query';\n                    if (procedure._def.mutation) {\n                        type = 'mutation';\n                    } else if (procedure._def.subscription) {\n                        type = 'subscription';\n                    }\n                    return procedure({\n                        path: fullPath,\n                        rawInput: args[0],\n                        ctx,\n                        type\n                    });\n                });\n                return proxy;\n            },\n            getErrorShape (opts) {\n                const { path , error  } = opts;\n                const { code  } = opts.error;\n                const shape = {\n                    message: error.message,\n                    code: TRPC_ERROR_CODES_BY_KEY[code],\n                    data: {\n                        code,\n                        httpStatus: getHTTPStatusCodeFromError(error)\n                    }\n                };\n                if (config.isDev && typeof opts.error.stack === 'string') {\n                    shape.data.stack = opts.error.stack;\n                }\n                if (typeof path === 'string') {\n                    shape.data.path = path;\n                }\n                return this._def._config.errorFormatter({\n                    ...opts,\n                    shape\n                });\n            }\n        };\n        return router;\n    };\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;\n\nexport { defaultTransformer as a, callProcedure as b, createRouterFactory as c, defaultFormatter as d, getDataTransformer as g, isServerDefault as i, procedureTypes as p };\n", "import { T as TRPCError } from './TRPCError-6a1653a4.mjs';\n\nfunction getRawProcedureInputOrThrow(opts) {\n    const { req  } = opts;\n    try {\n        if (req.method === 'GET') {\n            if (!req.query.has('input')) {\n                return undefined;\n            }\n            const raw = req.query.get('input');\n            return JSON.parse(raw);\n        }\n        if (!opts.preprocessedBody && typeof req.body === 'string') {\n            // A mutation with no inputs will have req.body === ''\n            return req.body.length === 0 ? undefined : JSON.parse(req.body);\n        }\n        return req.body;\n    } catch (cause) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            cause\n        });\n    }\n}\nconst deserializeInputValue = (rawValue, transformer)=>{\n    return typeof rawValue !== 'undefined' ? transformer.input.deserialize(rawValue) : rawValue;\n};\nconst getJsonContentTypeInputs = (opts)=>{\n    const rawInput = getRawProcedureInputOrThrow(opts);\n    const transformer = opts.router._def._config.transformer;\n    if (!opts.isBatchCall) {\n        return {\n            0: deserializeInputValue(rawInput, transformer)\n        };\n    }\n    /* istanbul ignore if  */ if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {\n        throw new TRPCError({\n            code: 'BAD_REQUEST',\n            message: '\"input\" needs to be an object when doing a batch call'\n        });\n    }\n    const input = {};\n    for(const key in rawInput){\n        const k = key;\n        const rawValue = rawInput[k];\n        const value = deserializeInputValue(rawValue, transformer);\n        input[k] = value;\n    }\n    return input;\n};\n\nexport { getJsonContentTypeInputs as g };\n", "import { b as callProcedure } from './config-cd32070b.mjs';\nimport { T as TRPCError, g as getTRPCErrorFromUnknown } from './TRPCError-6a1653a4.mjs';\nimport { t as transformTRPCResponse, g as getErrorShape } from './transformTRPCResponse-1153b421.mjs';\nimport { g as getJsonContentTypeInputs } from './contentType-53e30af8.mjs';\nimport { b as getHTTPStatusCode } from './index-f91d720c.mjs';\n\nconst HTTP_METHOD_PROCEDURE_TYPE_MAP = {\n    GET: 'query',\n    POST: 'mutation'\n};\nconst fallbackContentTypeHandler = {\n    getInputs: getJsonContentTypeInputs\n};\nfunction initResponse(initOpts) {\n    const { ctx , paths , type , responseMeta , untransformedJSON , errors =[] ,  } = initOpts;\n    let status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = responseMeta?.({\n        ctx,\n        paths,\n        type,\n        data,\n        errors,\n        eagerGeneration\n    }) ?? {};\n    for (const [key, value] of Object.entries(meta.headers ?? {})){\n        headers[key] = value;\n    }\n    if (meta.status) {\n        status = meta.status;\n    }\n    return {\n        status,\n        headers\n    };\n}\nasync function inputToProcedureCall(procedureOpts) {\n    const { opts , ctx , type , input , path  } = procedureOpts;\n    try {\n        const data = await callProcedure({\n            procedures: opts.router._def.procedures,\n            path,\n            rawInput: input,\n            ctx,\n            type\n        });\n        return {\n            result: {\n                data\n            }\n        };\n    } catch (cause) {\n        const error = getTRPCErrorFromUnknown(cause);\n        opts.onError?.({\n            error,\n            path,\n            input,\n            ctx,\n            type: type,\n            req: opts.req\n        });\n        return {\n            error: getErrorShape({\n                config: opts.router._def._config,\n                error,\n                type,\n                path,\n                input,\n                ctx\n            })\n        };\n    }\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router , req , onError  } = errorOpts.opts;\n    const error = getTRPCErrorFromUnknown(cause);\n    onError?.({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: getErrorShape({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = transformTRPCResponse(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n// implementation\nasync function resolveHTTPResponse(opts) {\n    const { router , req , unstable_onHead , unstable_onChunk  } = opts;\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        const headResponse = {\n            status: 204\n        };\n        unstable_onHead?.(headResponse, false);\n        unstable_onChunk?.([\n            -1,\n            ''\n        ]);\n        return headResponse;\n    }\n    const contentTypeHandler = opts.contentTypeHandler ?? fallbackContentTypeHandler;\n    const batchingEnabled = opts.batching?.enabled ?? true;\n    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';\n    let ctx = undefined;\n    let paths;\n    const isBatchCall = !!req.query.get('batch');\n    const isStreamCall = isBatchCall && unstable_onHead && unstable_onChunk && req.headers['trpc-batch-mode'] === 'stream';\n    try {\n        // we create context first so that (unless `createContext()` throws)\n        // error handler may access context information\n        //\n        // this way even if the client sends malformed input that might cause an exception:\n        //  - `opts.error` has value,\n        //  - batching is not enabled,\n        //  - `type` is unknown,\n        //  - `getInputs` throws because of malformed JSON,\n        // context value is still available to the error handler\n        ctx = await opts.createContext();\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (isBatchCall && !batchingEnabled) {\n            throw new Error(`Batching is not enabled on the server`);\n        }\n        /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n            throw new TRPCError({\n                message: 'Subscriptions should use wsLink',\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        if (type === 'unknown') {\n            throw new TRPCError({\n                message: `Unexpected request method ${req.method}`,\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        const inputs = await contentTypeHandler.getInputs({\n            isBatchCall,\n            req,\n            router,\n            preprocessedBody: opts.preprocessedBody ?? false\n        });\n        paths = isBatchCall ? decodeURIComponent(opts.path).split(',') : [\n            opts.path\n        ];\n        const promises = paths.map((path, index)=>inputToProcedureCall({\n                opts,\n                ctx,\n                type,\n                input: inputs[index],\n                path\n            }));\n        if (!isStreamCall) {\n            /**\n       * Non-streaming response:\n       * - await all responses in parallel, blocking on the slowest one\n       * - create headers with known response body\n       * - return a complete HTTPResponse\n       */ const untransformedJSON = await Promise.all(promises);\n            const errors = untransformedJSON.flatMap((response)=>'error' in response ? [\n                    response.error\n                ] : []);\n            const headResponse1 = initResponse({\n                ctx,\n                paths,\n                type,\n                responseMeta: opts.responseMeta,\n                untransformedJSON,\n                errors\n            });\n            unstable_onHead?.(headResponse1, false);\n            // return body stuff\n            const result = isBatchCall ? untransformedJSON : untransformedJSON[0]; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- `untransformedJSON` should be the length of `paths` which should be at least 1 otherwise there wouldn't be a request at all\n            const transformedJSON = transformTRPCResponse(router._def._config, result);\n            const body = JSON.stringify(transformedJSON);\n            unstable_onChunk?.([\n                -1,\n                body\n            ]);\n            return {\n                status: headResponse1.status,\n                headers: headResponse1.headers,\n                body\n            };\n        }\n        /**\n     * Streaming response:\n     * - block on none, call `onChunk` as soon as each response is ready\n     * - create headers with minimal data (cannot know the response body in advance)\n     * - return void\n     */ const headResponse2 = initResponse({\n            ctx,\n            paths,\n            type,\n            responseMeta: opts.responseMeta\n        });\n        unstable_onHead(headResponse2, true);\n        const indexedPromises = new Map(promises.map((promise, index)=>[\n                index,\n                promise.then((r)=>[\n                        index,\n                        r\n                    ])\n            ]));\n        for (const _ of paths){\n            const [index, untransformedJSON1] = await Promise.race(indexedPromises.values());\n            indexedPromises.delete(index);\n            try {\n                const transformedJSON1 = transformTRPCResponse(router._def._config, untransformedJSON1);\n                const body1 = JSON.stringify(transformedJSON1);\n                unstable_onChunk([\n                    index,\n                    body1\n                ]);\n            } catch (cause) {\n                const path = paths[index];\n                const input = inputs[index];\n                const { body: body2  } = caughtErrorToData(cause, {\n                    opts,\n                    ctx,\n                    type,\n                    path,\n                    input\n                });\n                unstable_onChunk([\n                    index,\n                    body2\n                ]);\n            }\n        }\n        return;\n    } catch (cause1) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - `router._def._config.transformer.output.serialize()` throws\n        // - post body is too large\n        // - input deserialization fails\n        // - `errorFormatter` return value is malformed\n        const { error , untransformedJSON: untransformedJSON2 , body: body3  } = caughtErrorToData(cause1, {\n            opts,\n            ctx,\n            type\n        });\n        const headResponse3 = initResponse({\n            ctx,\n            paths,\n            type,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: untransformedJSON2,\n            errors: [\n                error\n            ]\n        });\n        unstable_onHead?.(headResponse3, false);\n        unstable_onChunk?.([\n            -1,\n            body3\n        ]);\n        return {\n            status: headResponse3.status,\n            headers: headResponse3.headers,\n            body: body3\n        };\n    }\n}\n\nexport { resolveHTTPResponse as r };\n", "import { resolveHTTPResponse } from '@trpc/server/http';\n/**\n * Create a SvelteKit handle function for rRPC requests.\n *\n * If you want to use it in conjunction with other SvelteKit handles,\n * consider [the sequence helper function](https://kit.svelte.dev/docs/modules#sveltejs-kit-hooks).\n * @see https://kit.svelte.dev/docs/hooks\n */\nexport function createTRPCHandle({ router, url = '/trpc', createContext, responseMeta, onError }) {\n    return async ({ event, resolve }) => {\n        if (event.url.pathname.startsWith(url)) {\n            const request = event.request;\n            const req = {\n                method: request.method,\n                headers: request.headers,\n                query: event.url.searchParams,\n                body: await request.text()\n            };\n            const httpResponse = await resolveHTTPResponse({\n                router,\n                req,\n                path: event.url.pathname.substring(url.length + 1),\n                createContext: async () => createContext?.(event),\n                responseMeta,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onError: onError\n            });\n            const { status, headers, body } = httpResponse;\n            return new Response(body, { status, headers });\n        }\n        return resolve(event);\n    };\n}\n"],
  "mappings": "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",
  "names": ["_a", "_a", "observable", "_a", "_b", "TRPC_ERROR_CODES_BY_NUMBER", "_a", "_b", "item", "httpBatchLink", "_a", "_b", "_c", "_a", "getBody", "isObject", "_a", "_a"]
}
